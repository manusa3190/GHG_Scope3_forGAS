<template>
  <div class="flex justify-between h-full w-screen">
    <!-- 左側 -->
    <div>
      <div class="flex gap-4">
          <label class=" label max-w-44 cursor-pointer">
            <input type="checkbox" class="checkbox checkbox-xs" v-model="query.onlyMyItems" />
            <span class="label-text">自分の担当品目のみ</span> 
          </label>

          <label class=" label max-w-44 cursor-pointer">
            <input type="checkbox" class="checkbox checkbox-xs" v-model="query.onlyIncomplete" />
            <span class="label-text">未完了の品目のみ</span> 
          </label>

          <div v-if="useState().isLoading">
            <span class="loading loading-spinner loading-md"></span>同期中・・・
          </div>
      </div>

      <div class=" overflow-x-scroll p-2">
        <table id="index" class=" border table table-sm w-[500px]"></table> 
      </div>
    </div>

    <!-- 右側ウィンドウ -->
    <div class="bg-orange-100 h-full w-96 flex-none p-3">
      <div v-if="!原資材item" class="">原資材を選んでください</div>

      <div v-else class=" h-full flex flex-col">
          <Detail :key="原資材item? 原資材item['品目コード']:'0'" :原資材item="原資材item" @updated="updateConfig"></Detail>
      </div>
    </div>
  </div>
</template>

<script>

export default defineComponent({
  components:{Detail},
  async setup(){

    var grid;

    onMounted(async()=>{
        const 自所属原資材items = Object.values( useTables().自所属原資材docs)

        const columns = [
          {id:'品目コード',name:'品目コード',width:'130px'},
          {id:'品名',name:'品名',width:'250px'},
          {id:'取引先名',name:'取引先名',width:'150px'},
          {id:'担当者名', name:'担当者名', formatter: (cell, row) => cell? html(`<div>${cell}</div>`):html(`<div>担当者なし</div>`)},
          {id:'構成コード',hidden:true},
          {id:'構成コード',name:'登録',formatter: (cell, row) => cell? html(`<div>済</div>`):html(`<div>未</div>`)}
        ]

        grid = new Grid({
          columns,
          data:自所属原資材items,
          className:{
            td:'max-w-52 truncate'
          },
          sort:true,    
        })

        grid.on('rowClick',(...args)=>{
          const {cells} = args[1]
          const 品目コード = cells[columns.findIndex(c=>c==='品目コード'||c.id==='品目コード')].data
          const {自所属原資材docs} = useTables()
          原資材item.value = {...自所属原資材docs[品目コード]}

          useState().$patch({isEdit:!原資材item.value.構成コード})
        })

        grid.render(document.getElementById('index'))
    })

    const {get自所属users} = useUsers()
    const {fetch自所属原資材docs, fetch使いまわし情報docs} = useTables()
    const {fetchマスタ} = useMasters()

    await Promise.all([
      get自所属users(), fetch自所属原資材docs(), fetch使いまわし情報docs(), fetchマスタ()
    ])

    const 原資材item = ref()

    const query = reactive({
      onlyMyItems:true,
      onlyIncomplete:true
    })
    watch(query,()=>{
      if(!grid)return

      let items = Object.values( useTables().自所属原資材docs)
      if(query.onlyMyItems){
        items = items.filter(item=>item['担当者メールアドレス']===currentUserEmail.innerText)
      }
      if(query.onlyIncomplete){
        items = items.filter(item=>!item['構成コード'])
      }

      grid.updateConfig({data:items})
      grid.forceRender()
    })

    const updateConfig = () =>{
      grid.updateConfig({data:Object.values(useTables().自所属原資材docs)})
      grid.forceRender()
      useState().$patch({isLoading:false})
    }

    return { query, 原資材item, useState, updateConfig}
  }
})

</script>